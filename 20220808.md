# 4. 변수

**변수**는 값에 접근하기 위해 메모리 주소(공간)에 붙이는 **식별자**이다. 

식별자는 값을 구별해서 식별할 수 있는 고유한 이름이다. 즉, 식별자가 기억하고 있는 메모리 주소를 통해 값에 접근할 수 있다는 뜻이다. 변수 뿐만 아니라 함수, 클래스 등 모두 식별자이다. 

다음 사진에서 eggs, fizz가 변수 이름이 되고 15, 10이 변수 값이다. 변수 이름을 붙이기 전에는 메모리 주소로만 값에 접근할 수 있는데 이는 안전하지 못한 방법이고 변수로 선언하여 접근하는게 안전한 방법이다. 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3e022e76-58a1-4519-8df6-36137684773f/Untitled.png)

**변수 선언**은 선언 단계와 초기화 단계로 나뉜다. 

**선언 단계**에서는 변수 이름이 등록되고, **초기화 단계**에서는 메모리 공간 확보 후 암묵적으로 undefined를 할당한다. var키워드를 사용하는 경우 선언 단계와 초기화 단계가 동시에 진행된다. 

let, const는 어떻게??(15장)

모든 선언문은 소스코드 실행(런타임) 전 평가시 실행된다. 따라서 선언문이 코드 선두로 올려진 것처럼 동작하는 데 이를 **변수 호이스팅**이라고 한다. 

**값의 할당**은  undefined에서 설정한 값으로 재할당된다. **재할당**은 원래 메모리 공간에 값을 덮어쓰는 것이 아니라 새로운 메모리 공간을 확보하고 값을 저장하는 방식이다. 

# 5. 표현식과 문

**토큰**은 문법적인 의미를 갖는 코드의 기본 요소

**문**은 프로그램을 구성하는 기본 단위이자 최소 실행 단위

토큰이 모여서 문이 되고 문이 모여서 프로그램이 된다!!!

**값**은 식이 평가되어 생성된 결과

**표현식**은 값으로 평가될 수 있는 문으로 변수에 할당할 수 있다. 

문은 표현식인 문과 표현식이 아닌 문으로 나눌 수 있다. 

# 6. 데이터 타입

- 숫자 타입: 정수형이 따로 존재하지 않고 64비트 부동소수점 형식으로 숫자를 표현한다.  즉, 실수다~
- 문자열 타입: 16비트 유니코드 문자(UTF-16)의 집합이다. 유니코드는 전세계 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 표준이다. ES6에 도입된 템플릿 리터럴은 백틱을 사용해서 문자열을 표현하고 런타임에 일반 문자열로 변환되어 처리된다. 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 기능을 제공한다.
    - 멀티라인 문자열: 일반 문자열은 이스케이프 시퀀스로 개행을 표시하는데 템플릿 리터럴은 개행을 허용한다.
        - 라인 피드(\n): 커서 정지 상태에서 종이 한 줄 올리기
        - 캐리지 리턴(\r): 종이를 움직이지 않고 커서를 맨 앞으로
    - 표현식 삽입: 일반 문자열은 문자열 연산자 +로 문자열 조합하는데 템플릿 리터럴은 ${ }으로 표현식을 삽입할 수 있다.
    - 태그드 템플릿: 템플릿 리터럴에서 정적인 문자열과 표현식(${ }로 입력받은)을 분리할 수 있다. 함수의 첫번째 파라미터는 정적인 데이터가 저장되고 나머지 파라미터에 동적인 데이터가 저장된다.
- 불리언 타입: true, false
- undefined 타입: 값을 할당하지 않은 변수라는 뜻으로 자바스크립트 엔진이 변수 초기화할 때 사용하는 값이다.
- null 타입: 개발자가 변수에 값이 없다는 것을 의도적으로 명시할 때 사용하는 값이다.
- 심벌 타입: 다른 값과 중복되지 않는 값(33장)
- 객체 타입: 자바스크립트를 이루는 거의 모든 것이 객체다!!(11장)

**데이터 타입**이 필요한 이유

1. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하고
2. 값을 참조할 때 한번에 읽어야 하는 메모리 공간의 크기를 결정하고
3. 메모리에서 읽은 2진수를 어떻게 해석할지 결정해야하기 때문이다.

**정적 타입 언어**는 변수 선언 시점에 변수의 타입이 결정되고 타입을 변경할 수 없다. 

자바스크립트 같은 **동적 타입 언어**는 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고 타입을 변경할 수 있다. 

# 7. 연산자

- 산술연산자
    - 증감연산자는 값이 변경되는 **암묵적 할당**이 이뤄진다.
    - 문자열 연결 연산자는 피연산자의 타입을 문자열로 바꾸는 **암묵적 타입변환**이 이뤄진다.
- 비교연산자
    - 동등비교연산자(==)는 **암묵적 타입변환**을 통해 타입을 일치시킨 후 비교한다.
    - 일치비교연산자(===)는 값과 타입이 일치하는지 비교한다. 좀 더 엄격하다고 할 수 있지~
        
        **NaN은 자기자신과 일치하지 않는 유일한 값으로 Number.isNaN으로 확인해야한다.**
        
- 삼항조건연산자
    - 조건문은 표현식이 아닌 문으로 변수에 할당할 수 없지만 삼항조건연산자는 표현식인 문이기 때문에 값으로 평가되어 변수에 할당할 수 있다.
- 논리연산자
    - and(&&)와 or(||) 연산자는 두개의 피연산자 중 한쪽으로 평가된다.(**단축평가**)
- typeof 연산자
    - (!!!버그) typeof null = object 따라서 null타입인지 확인할 때 일치연산자를 사용해야한다.
- **옵셔널 체이닝 연산자**(?.) ES11
    - 왼쪽 피연산자가 null이거나 undefined인 경우 undefined를 반환하고 아닌 경우 오른쪽의 프로퍼티를 참조한다.(**단축평가**)
- **null 병합 연산자**(??) ES11
    - 왼쪽 피연산자가 null이거나 undefined인 경우 오른쪽 피연산자를 반환하고 아닌 경우 왼쪽 피연산자를 반환한다.(**단축평가**)

# 8. 제어문

- 블록문은 중괄호로 묶은 문으로 하나의 실행 단위이다. 또한, 자체적인 종결성을 갖기 때문에 세미콜론을 생략한다.
- **조건문**은 조건식의 평가결과에 따라 코드 블록의 실행을 결정한다.
    - if else문은 조건식의 결과(불리언값으로 암묵적 변환)에 따라 실행흐름을 이동한다.
    - switch문은 표현식과 값이 일치하는 case문으로 실행흐름을 이동한다.
        
        **폴스루**(fall through): case문 실행 후 switch문을 탈출하지 않아서 이후 case문과 default문을 실행한 것
        
        ⇒폴스루를 이용하여 여러 case문을 하나의 조건으로 사용할 수 있다!!
        
- **반복문**은 조건식이 거짓이 될 때까지 반복해서 실행한다.
- **break문**은 코드블록(반복문, switch문, 레이블문)을 탈출한다.
- **continue문**은 반복문의 코드블록 실행을 중단하고 증감식으로 실행흐름을 이동한다.

# 9. 타입변환과 단축평가

**타입변환**은 기존 원시값을 변경하는 것이 아니라 새로운 원시값을 생성하는 것이다.

- **명시적 타입변환(타입 캐스팅)**은 개발자가 의도적으로 타입을 바꾸는 것이다.
- **암묵적 타입변환(타입 강제변환)**은 자바스크립트 엔진에 의해 암묵적으로 타입이 바뀌는 것을 의미한다.

자바스크립트 엔진은 불리언 타입이 아닌 값을 **Truthy**값과 **Falsy**값으로 구분하고 Truthy는 true로 Falsy는 false로 변환한다. false, undefined, null, 0, -0, NaN, ‘’(빈문자열)은 Falsy값이다!!

**단축평가**는 표현식을 평가하는 도중에 평가결과가 확정되는 경우 나머지 평가과정을 생략하는 것을 의미한다.

1. **논리연산자(&&, ||)** 표현식은 2개의 피연산자 중 한쪽으로 평가된다. 
    1. A(Truthy) && B ⇒ B
    2. A(Falsy) && B ⇒ A (B평가 안 하고 결과 반환)
    3. A(Truthy) || B ⇒ A (B평가 안 하고 결과 반환)
    4. A(Falsy) || B ⇒ B
2. **옵셔널 체이닝 연산자**는 좌항 피연산자가 null, undefined인 경우 undefined반환하고, 아니면 우항 프로퍼티를 참조한다. 객체를 가리키기를 기대하는 변수가 비어있는지 확인하고 프로퍼티 참조할 때 유용하다. 
3. **null 병합 연산자**는 좌항 피연산자가 null, undefined인 경우 우항 피연산자를 반환하고, 아니면 좌항 피연산자를 반환한다. 변수에 기본값을 설정할 때 유용하다.
