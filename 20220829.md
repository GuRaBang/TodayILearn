# 브라우저 렌더링 과정

## ⭐브라우저 렌더링 과정⭐

브라우저의 핵심 기능은 리소스를 서버에 요청하고 응답받아 시각적으로 렌더링하는 것이다. 

[https://www.google.com을](https://www.google.com을) 검색했을 때 과정

**URL의 호스트 이름인 www.google.com이 DNS 서버를 통해 IP주소로 변환된다.** 

DNS는 도메인을 IP주소로 매핑해주는데 도메인은 식별자와 같은 역할을 하고 IP는 식별자의 주소 역할을 한다. 즉, 숫자로만 이루어진 IP주소를 사용자가 외우기 어렵기 때문에 사용자가 이해할 수 있는 도메인을 사용하는 것이다. 

**이 IP주소를 갖는 서버에게 파일(경로가 없는 경우에 index.html)을 요청하고 응답받는다.** 

**브라우저 렌더링 엔진은 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성하고 결합하여 렌더트리를 생성한다.** 

**만약 파싱 중 자바스크립트 파일을 만나는 경우 자바스크립트 엔진에게 제어권이 넘어가서 AST를 생성하고 바이트코드로 변환하여 실행한다. 이때 DOM API를 통해 DOM과 CSSOM이 변하는 경우 다시 렌더트리로 결합된다.** 
<br/>


### <DOM 파싱 과정>

파싱은 순수한 텍스트인 문서를 브라우저가 이해할 수 있는 자료구조로 변환하는 과정이다. 

서버에서 응답받은 HTML파일은 **바이트** 형태이다. 

바이트의 형태의 문서를 meta태그의 charset에 지정된 인코딩 방식을 기준으로 **문자열**로 변환한다.   

문자열을 문법적 의미를 갖는 최소단위인 **토큰**으로 분해하고, 토큰을 객체로 변환하여 **노드**를 생성한다. 

HTML요소는 중첩관계를 갖는데 이러한 문법적인 구조를 반영하여 트리 자료구조인 **DOM** 을 구성한다. 

⭐**DOM은 작은 범위로는 노드의 트리형태 자료구조를 의미하지만, 큰 범위로 보면 DOM을 조작할 수 있는 API를 포함한다**. 
<br/>


### <자바스크립트 파싱 과정>

**문자열**을 문법적 의미를 갖는 **토큰**으로 분해하고 문법적 의미와 구조를 반영하여 **AST**(추상적 구문 트리)를 생성한다. AST를 인터프리터가 실행할 수 있는 **바이트코드**로 변환하여 파일을 실행한다. 
<br/>
<br/>


## async / defer

자바스크립트 엔진과 브라우저 렌더링 엔진은 직렬적으로, 즉 동기적으로 파싱한다. 그렇기 때문에 아래와 같은 이유로 script 태그의 위치가 중요하다. 

1) DOM이 완성되지 않았을 때 자바스크립트에서 DOM을 조작하면 에러가 발생한다. 

2) 자바스크립트 로딩/파싱/실행으로 인해 HTML 파싱이 블로킹되어 DOM 생성이 지연되고 렌더링에 지장이 생긴다. 

따라서 script태그를 body 가장 아래에 위치시킨다. 

그러나 자바스크립트 파싱에 의해 DOM 생성이 중단되는 문제는 동기적으로 일어나기 때문이고 이를 해결하기 위해 script태그에 async와 defer어트리뷰트가 추가되었다. 

두 어트리뷰트는 외부 자바스크립트 파일 로드와 HTML파싱이 비동기적으로 진행된다는 공통점이 있지만 자바스크립트 실행 시점에 차이가 있다.  

async는 자바스크립트 파일 로드가 완료된 직후 HTML파싱을 중단하고 자바스크립트 파싱과 실행이 진행된다.  

defer는 HTML 파싱이 완료된 직후 자바스크립트 파싱과 실행이 진행된다. 

⭐자바스크립트 module(ESM)은 기본적으로 defer로 동작한다. 하지만 현업에서는 ESM을 거의 사용하지 않고 webpack으로 번들링해서 사용한다. 

⭐async는 잘 사용하지 않지만 용량이 큰 font를 로드할 때 렌더링하려면 빨리 가져와야하기 때문에 사용하는 경우가 있다. 

⭐defer를 가장 많이 사용한다. script가 body에 흩어져 있는 것이 미관상? 좋지 않고 head에 있는게 좋기 때문에 defer를 사용한다.  

DOMContentLoaded 이벤트는 더 이상 DOM에 추가될 것이 없음을 의미한다. 즉, DOM의 완성을 뜻한다. 

⇒ 첫 화면이 로딩되었을 때 어떤 동작을 하도록 구현하는 경우 사용한다. 

Loaded 이벤트: 모든 리소스(HTML, CSS, JS, 이미지)의 로딩이 완료되었음을 의미한다. 

⇒ 주로 이미지 로딩할 때 많이 사용한다. lazy loding 구현할 때
<br/>
<br/>


## ⭐리플로우 & 리페인트⭐

 DOM API를 사용하여 DOM과 CSSOM을 변경하는 경우 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃과 페인팅 과정을 거쳐 렌더링한다. 

레이아웃을 다시 계산하는 것을 리플로우라고 하고, 페인팅을 다시 하는 것을 리페인트이라 한다. 

여기서 리플로우가 중요하다‼ 

리플로우의 경우 레이아웃 계산을 다시 하고 리페인트도 발생하기 때문에 리플로우를 덜 일으키도록, 즉 DOM조작을 최대한 안 하도록 코딩해야한다. 

⭐ 렌더링에 있어서 성능도 생각해야한다. 사용자 경험 UX에 영향을 주기 때문에

⭐가독성과 성능 중? 코딩은 가독성 좋게 먼저 구현하고 성능 개선을 순서로 해야한다. 

⭐ 성능은 거의 이미지와 관련이 있다. 

⭐ React, Angular는 어떻게 렌더링을 효율적이게 할 것인가에 초점을 맞춘 라이브러리다. 

⭐ 결국은 React를 쓸거지만 자바스크립트에 왜,어떤 문제가 있는지를 알아야한다.
<br/>
<br/>
<br/>
<br/>




# DOM API

## 요소 노드 취득

- id는 getElementById 사용
- 나머지는 querySelector, querySelectorAll 사용

⇒ 대신 live인 경우가 있기 때문에 배열로 변환해서 사용해라

⭐input처럼 특수한 경우(input id와 label for 연결해야함)가 아니면 id 안 쓰는 게 좋다. 
<br/>
<br/>


## NodeList & HTMLCollection

HTMLCollection과 NodeList는 DOM API가 여러개의 결과값을 반환하기 위한 DOM Collection 객체다. 두 컬렉션 객체 모두 유사배열 객체면서 이터러블이다. 또한, 노드 객체의 상태 변화를 실시간으로 반영하는 살아있는 객체로 동작한다. NodeList는 대부분 노드 객체의 상태 변화를 실시간으로 반영하지 않고 과거의 정적 상태를 유지하는 non-live 객체로 동작하지만 경우에 따라 live 객체로 동작한다. 

⇒ 상태 변화와 상관없이 안전하게 DOM 컬렉션을 사용하기 위해 배열로 변환하여 사용하는 것이 좋다. 
<br/>
<br/>


## 노드 탐색

- 공백 텍스트 노드 주의(요소 사이의 공백 문자는 텍스트 노드를 생성한다.)
- Element 붙은 프로퍼티 사용(텍스트 노드를 포함하지 않는다.)
- 부모 노드 탐색 프로퍼티는 parentNode밖에 없다.(텍스트 노드가 부모가 될 수 없기 때문에)

## 크로스 사이트 스크립팅 공격

HTML 마크업이 파싱되어 DOM에 반영되는 innerHTML프로퍼티와 insertAdjacentHTML메서드는 사용자로부터 입력받은 데이터를 그대로 DOM에 반영하는 경우 악성 코드가 그대로 실행될 가능성이 있기 때문에 크로스 사이트 스크립팅 공격(XSS)에 취약하다. 

untrusted data에 대하여 HTML마크업을 새니티제이션하여 잠재적인 위험을 제거할 수 있다. 
<br/>
<br/>


## 복수 노드 추가

DocumentFragment 노드는 컨테이너 요소와 같이 자식 노드들의 부모 노드로서 별도의 서브 DOM을 구성하여 기존 DOM에 추가하기 위한 용도로 사용한다. 기존 DOM과 별도로 존재하기 때문에 DocumentFragment 노드에 자식 노드를 추가해도 기존 DOM에는 변경이 발생하지 않고, DOM에 추가하면 자신은 제거되고 자식 노드만 기존 DOM에 추가된다. 

⇒ 리플로우와 리페인트가 한번만 실행되기 때문에 효율적이다. 
<br/>
<br/>


## 프로퍼티와 어트리뷰트의 차이

HTML 어트리뷰트는 두가지 방식으로 관리된다. 

1) 요소 노드의 attributes 프로퍼티가 관리하는 어트리뷰트 노드

2) 요소 노드의 프로퍼티(DOM 프로퍼티) 

HTML 어트리뷰트는 HTML 요소의 초기 상태를 의미하며, 이는 변하지 않는다. 

하지만 렌더링 이후 요소 노드의 상태는 사용자의 입력에 의해 변화한다. 

즉, 요소 노드는 2개의 상태(초기 상태와 최신 상태)를 관리해야 하는데, 요소 노드의 초기 상태는 어트리뷰트 노드가 관리하고 최신 상태는 DOM프로퍼티가 관리한다.   

⭐ 사용자에게 입력 받은 값을 읽으려면 프로퍼티에 접근해야 한다. 
<br/>
<br/>


## classList

class 어트리뷰트에 대응하는 DOM 프로퍼티는 className과 classList다. 

className은 class 어트리뷰트 값을 문자열로 반환하고 

classList는 class 어트리뷰트의 정보를 담은 DOMTokenList 객체(유사배열객체면서 이터러블)를 반환한다. 

⇒ DOMTokenList 객체는 메서드를 제공하기 때문에 더 유용하다.
