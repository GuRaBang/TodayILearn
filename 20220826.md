# 정규 표현식

정규 표현식은 일정한 **패턴을 가진 문자열**의 집합을 표현하기 위해 사용하는 형식 언어다. 정규 표현식은 문자열을 대상으로 **패턴 매칭 기능**을 제공한다. 정규 표현식을 사용하면 반복문과 조건문 없이 패턴을 정의하고 테스트하는 것으로 간단히 체크할 수 있지만 가독성이 좋지 않다. (아직 대체가 없다… 가독성이 좋지 않지만 기능이 강력하다.) 정규 표현식은 패턴과 플래그로 구성되는데 패턴은 문자열의 일정한 규칙을 표현하고, 플래그는 정규 표현식의 검색 방식을 설정하는 데 사용한다. 

# Symbol

변경 불가능한 원시 타입의 값으로 심볼 값은 다른 값과 중복되지 않는 유일무이한 값이다. 심볼은 주로 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다. (기존 프로퍼티 키와 충돌하지 않으면서 미래에 추가될 어떤 프로퍼티와도 충돌할 위험이 없다.) **심벌은 중복되지 않는 상수 값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해, 즉 하위 호환성을 보장하기 위해 도입되었다.** 

Symbol 함수를 사용하여 호출할 때마다 심볼 값을 생성하면 심볼 값을 검색할 키를 지정할 수 없다. 

하지만 Symbol.for 메서드를 사용하면 심볼 값을 단 하나만 생성하여 전역 심벌 레지스트리를 통해 공유할 수 있다. 

# 이터러블

먼저, 이터러블이 되려면 이터러블 프로토콜을 준수해야 한다. 이터러블 프로토콜의 핵심은 Symbol.iterator메서드를 호출했을 때 이터레이터를 반환하는 것이다. 여기서 나오는 이터레이터는 이터레이터 프로토콜을 준수하는 객체를 의미한다. 이터레이터 프로토콜은 next메서드를 호출했을 때 이터러블을 순회하며 이터레이터 리절트 객체를 반환하는 것을 뜻한다. 이터레이터 리절트 객체는 해당 순서의 값과 순회가 완료되었는지를 나타내는 값을 프로퍼티로 갖고있다. 즉, 이 프로토콜을 만족하는 이터러블은 자료구조의 종류에 상관없이 동일한 방식으로 순회를 할 수 있다. 

이터레이션 프로토콜은 순회 가능한 자료구조를 만들기 위해 ES6에 도입된 규칙이다. 

ES6 이전의 순회 가능한 자료구조는 통일된 규약 없이 각자의 구조를 가지고 다양한 방법으로 순회할 수 있었다. 

ES6에서는 순회 가능한 자료구조를 이터레이션 프로토콜을 따르는 이터러블로 통일하여 for…of문, 스프레드 문법, 배열 디스트럭처링 할당을 사용할 수 있도록 일원화했다. 

즉, 이터레이션 프로토콜은 자료구조가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 자료구조를 사용할 수 있도록 인터페이스 역할을 한다. 

Symbol.iterator를 프로퍼티 키로 사용한 메서드를 호출했을 때 이터레이터 객체를 반환하는 규약을 이터러블 프로토콜이라고 한다. 이터러블 프로토콜을 준수한 객체를 이터러블이라 한다. next 메서드를 소유하며 next 메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환하는 규약을 이터레이터 프로토콜이라 한다. 이터레이터 프로토콜을 준수한 객체를 이터레이터라고 한다. 이터레이터는 이터러블 요소들을 탐색하기 위한 포인터 역할을 한다. 

원래는 이터러블만 for…of문으로 순회할 수 있고 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있었는데 일반 객체에 스프레드 문법과 배열 디스트럭처링을 할 수 있다. 

for…of문은 내부적으로 이터레이터의 next메서드를 호출하여 이터러블을 순회하며 next 메서드가 반환한 이터레이터 리절트 객체의 value값을 for…of문의 변수에 할당한다. 

유사 배열 객체는 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 유사 배열 객체는 이터러블이 아닌 일반 객체이므로 Symbol.iterator메서드가 없기 때문에 for…of문으로 순회할 수 없다. 

배열이나 문자열 등은 모든 데이터를 메모리에 미리 확보한 다음 데이터를 공급한다. 하지만 이터러블은 데이터가 필요한 시점이 되어서야 데이터를 생성하기 때문에 빠른 실행 속도를 기대할 수 있고 무한도 표현할 수 있다는 장점이 있다. 

# 스프레드 문법

하나로 뭉쳐 있는 여러 값들의 집합을 전개하여 개별적인 값의 목록으로 만든다. 스프레드 문법은 쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다. e.g. 함수 호출문의 인수 목록, 배열 리터럴의 요소 목록, 객체 리터럴의 프로퍼티 목록. 

Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받기 위해 매개변수 이름 앞에 …을 붙이는 것이다. Spread 문법은 여러개의 값이 하나로 뭉쳐 있는 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만드는 것이다. 

# 디스트럭처링 할당

말그대로 구조화된 배열이나 객체를 분해하여 1개 이상의 변수에 개별적으로 할당하는 것을 의미한다. 디스트럭처링 할당은 배열 디스트럭처링 할당과 객체디스트럭처링 할당으로 나뉜다. 배열 디스트럭처링의 경우 할당 기준은 배열의 인덱스고 객체 디스트럭처링의 경우 할당 기준은 프로퍼티 키다. 

스프레드 문법과 rest 문법은 유용하기 때문에 잘 알아둬야한다!
