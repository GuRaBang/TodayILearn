# 22. this

메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야한다. 

생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수가 존재해야한다. 즉, 아직 생성할 인스턴스를 가리키는 식별자를 알 수 없기 때문에 특수한 식별자가 필요하고 이게바로 this다. **this**는 자신이 속한 **객체** 또는 자신이 **생성할 인스턴스**를 가리키는 **자기 참조 변수**다. this를 통해 자신이 속한 객체나 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. this는 자바스크립트 엔진에 의해 암묵적으로 생성되며 함수를 호출하면 arguments객체와 this가 암묵적으로 함수 내부에 전달된다. this가 가리키는 값(this 바인딩)은 **함수 호출 방식**에 의해 동적으로 결정된다. 

## 함수 호출 방식과 this 바인딩

this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.  

- 일반 함수 호출: 전역객체, undefined(strict mode)
    
    ⇒ this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 일반적으로 객체의 메서드 내부나 생성자 함수 내부에서만 의미가 있다. 일반 함수 내부에서 this가 필요없다.
    
    일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역객체가 바인딩된다. 중첩함수와 콜백함수는 헬퍼 함수의 역할을 하므로 외부함수의 일부 로직을 대신하는데 외부함수인 메서드와 중첩함수 또는 콜백함수의 this가 일치하지 않는 것은 헬퍼 함수로 동작하기 어렵게 만든다. 
    
    ⇒ this를 명시적으로 바인딩하는 메서드를 사용한다. Function.prototype.apply/call/bind 
    
- 메서드 호출: 메서드를 호출한 객체, 마침표 연산자 앞에 있는 객체
- 생성자 함수 호출: 생성자 함수가 생성할 인스턴스
- Function.prototype.apply/call/bind 메서드에 의한 간접 호출
    - apply: this로 사용할 객체와 인수 리스트(배열)를 인수로 전달받아 함수를 호출한다.
    - call: this로 사용할 객체와 인수 리스트(리스트)를 인수로 전달받아 함수를 호출한다.
    - bind: this로 사용할 객체를 전달받아 this바인딩이 교체된 함수를 새롭게 생성해 반환한다. 메서드와 메서드 내부 중첩함수나 콜백함수의 this가 불일치하는 문제를 해결할 때 유용하게 사용한다.

# 23. 실행 컨텍스트

실행 컨텍스트를 이해하면 식별자 바인딩, 호이스팅, 클로저, 태스크 큐, 이벤트 핸들러, 비동기 처리의 동작방식을 이해할 수 있다. 

## 소스코드의 타입

4가지 타입의 소스코드는 실행 컨텍스트를 생성한다. 

- 전역 코드: 전역에 존재하는 소스코드 ⇒ 전역 실행 컨텍스트
- 함수 코드: 함수 내부에 존재하는 소스코드 ⇒ 함수 실행 컨텍스트
- eval 코드: 빌트인 전역 함수인 eval함수에 인수로 전달되어 실행되는 소스코드 ⇒ eval 실행 컨텍스트
- 모듈 코드: 모듈 내부에 존재하는 소스코드 ⇒ 모듈 실행 컨텍스트

## 소스코드의 평가와 실행

자바스크립트 엔진은 소스코드를 평가와 실행 과정으로 나눠서 처리한다. 

소스코드 **평가 과정**에서 실행 컨텍스트를 생성하고, 선언문만 먼저 실행하여 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.

소스코드 **실행 과정**에서 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득하고 변수 값의 변경 등 실행 결과는 실행 컨텍스트가 관리하는 스코프에 등록한다.   

## 실행 컨텍스트의 역할

# 수업정리

## 아스키코드

컴퓨터는 0,1로 이해한다. 

문자를 컴퓨터가 이해할 수 있는 숫자로 바꿔주는 규칙 중 하나가 아스키 코드

ANSI(미국 협회)에서 만든것 중 하나다~ 

한국은? KS에서 만든 EUC-KR 썼는데 국제적인 표준이 필요해졌다. 

아스키코드는 8비트(1바이트)로 문자(영어)를 표현한다. 

1바이트=8비트 라는 개념이 굳어진게 여기서?   

## 유니코드

아스키코드의 문제? 영어밖에 표현 못해

⇒ 다양한 언어를 표현하기 위해 유니코드(uni = 1개에)

UTF-8은 아스키코드를 가장 잘 호환할 수 있다. 

UTF-8은 **가변 인코딩 방식**을 채택한다. (영어는 1바이트, 한글은 3바이트 채택)

컴퓨터가 몇 바이트 쓰는지 어떻게 아냐? 맨앞에 표시를 해준다. 

*왜 진수는 36진수까지? 0~9, A~Z

## 함수

lazy가 좋다~

함수객체는 호출할 수 있는 객체일뿐 함수 내부 프로세스와 아무 관계가 없다. 

함수는 호출되었을 때 코드 내부의 평가와 실행이 되는 것이다!!!

```jsx
// 런타임에는 함수 객체가 만들어질 뿐
// 나중에 호출할 때 함수 객체의 내부 메서드 [[Call]]을 불러서 함수 내부 코드를 평가하고 실행하는 것

const f = function(){};

// 1. 런타임 전에 
// 선언전 환경 레코드에 f를 키로 등록한다.(key와 value는 쌍으로 존재하니까 무슨 값인지는 모르지만 어떤 값이 들어가있을 것이다.)
// 2. 런타임에
// f라는 식별자가 존재하는지 확인하고 
// 할당전에 함수 객체를 만든다.(호출과 상관없다. 함수객체 프로퍼티 어트리뷰트들 준비)
// 함수 객체를 생성하고 f의 값에 함수 객체를 할당한다.   
// 3. 호출 되었을 때 내부 코드를 평가하고 실행한다.
```

선언문은 모두 호이스팅이 된다!!!

⇒ 함수 객체와 함수 호출은 분리해서 생각해야한다.

*ECMAScript사양에는 원래 메서드가 없다. 모두 함수라고 지칭한다. 그런데 ES6에 메서드 축약 표현이 등장하면서 메서드라고 지칭하기 시작함. 

## 실행 컨텍스트

```jsx
var a = 1;
(window.)a + 1

// a를 전역객체에서 찾아야한다. 
```

전역스코프와 전역객체가 연결되어야 한다. 

ES5시절에는 전역스코프가 전역객체였다!!

```jsx
const a = 1;

// a는 전역객체에 있다? 없다~~
// 다른 공간에 있어야 한다!
```
