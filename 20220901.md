# 비동기

setTimeOut : 브라우저에 타이머 등록

콜백함수 호출하는 건 브라우저. 정확히는 이벤트 루프
<br/>
<br/>

**비동기 키워드: 블로킹(문제), 동시성(목적), 이벤트루프(해결)**

자바스크립트가 싱글스레드는 아니다. 자바스크립트 엔진이 (정확히는 콜스택이) 싱글스레드다.

멀티스레드는 코드가 복잡해진다. 

⇒ 자바스크립트는 싱글스레드 언어다. 

⇒ 싱글스레드의 문제는 블로킹이 발생하는 것이다.  

⇒ 태그스큐와 **이벤트루프**로 동시성 확보

⇒ 함수를 호출하면 실행컨텍스트 스택에 쌓인다. 비동기 함수는 web api가 실행하고 비동기 함수에 전해진 콜백은 비동기 함수 실행 종료 후 태스크 큐에 들어간다. 이벤트 루프는 콜 스택과 태스크 큐를 감시하다가 콜 스택이 비어있으면 태스크 큐에 있던 콜백함수를 콜스택으로 밀어 넣는다. 
즉, 콜백함수를 호출한 것은 브라우저다. 
<br/>
<br/>


비동기를 언제쓸까? 

서버와 클라이언트(브라우저)는 물리적으로 떨어져있다. 

뷰를 그리기 위한 리소스는 서버에 존재한다. 

리소스를 서버에게 요청하고 응답받는다. 

통신은 HTTP를 이용하는데 GET/POST등등

HTTP통신의 이점을 잘 활용할 수 있도록 만든 규약이** REST**(컨벤션이다.), 지키는 것이 **REST API **

이 컨벤션을 따르면 커뮤니케이션이 단순해진다.

***백엔드가 대부분 API를 만들어주지만 커뮤니케이션이 가능해야하기 때문에 REST API를 알아야 한다. 그리고 목서버를 만들 일도 많다.(대부분 API 개발전이기 때문에 테스트하려면 만들수밖에) REST API 세부사항들은 이미 결정되어 있기 때문에 비슷한 목서버를 만들고 테스트

XMLHTTPRequest → fetch → axios 

CS간 데이터 전송은 문자열(정확히는 전압)로 된다. 

객체를 어떻게 문자열로 바꾸냐?? 이럴때 **json**을 쓴다. 

과거에는 xml을 썼다. 

xml은 html처럼 태그로 감싸는데 본 정보보다 메타데이터 양이 더 많다. ⇒ 배보다 배꼽이 더 크다

json은 딱 정보만 담고 있다. ⇒ 가볍다. 
<br/>
<br/>


**제너레이터**는 이터러블을 간단하게 구현할 때 사용

async, await는 제너레이터와 내부동작이 비슷할 것이다. 

하지만 **async, await**는 내부외부 왔다갔다 하는데 쓰면 안 된다. 그럴거면 제너레이터를 사용해야한다. 

***비동기는 async, await을 사용해라***

하지만 await 뒤에는 프로미스만 올 수 있다. 

즉, 프로미스를 알아야한다!!

*** top level에서 await를 사용할 수 있다.(크롬에서) ⇒ 지금 제안중인 사항임
<br/>
<br/>


## ⭐에러처리⭐

빨리 버그를 찾으려면 에러를 빨리 감지할 수 있어야한다. 

⇒ 에러를 파일에 기록해야한다. 

1) 에러발생지점에서 에러를 처리할 것이냐

2) 탑레벨에서 에러를 처리할 것이냐 

대부분 탑레벨에서 에러 처리한다. (발생지점마다 에러처리하는 것은 비효율적)

⇒ 즉, 에러가 전파되어야 한다… 에러는 caller방향으로 전파한다. 

⇒ 에러 처리는 try, catch로 한다. 

**async, await는 콜백헬도 해결하고 try, catch도 사용할 수 있다.**

***console.error를 통해 에러를 보여줄 수 있다.***

