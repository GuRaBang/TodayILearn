# 13. 스코프

모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 자신을 참조할 수 있는 유효범위가 결정된다.(정적스코프, 렉시컬스코프) 즉, 스코프는 식별자가 유효한 범위이다. 식별자를 검색할 때  사용하는 규칙입니다. 

*코드의 문맥은 렉시컬 환경에서 이뤄지고 이를 구현한게 실행컨텍스트이다. 

*let, const로 선언된 변수와 var로 선언된 변수의 스코프가 다르게 동작한다. 

*함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정하는 것이 동적스코프이다. 

*함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정하는 것이 정적스코프, 렉시컬 스코프다. 

*자바스크립트는 렉시컬 스코프를 따르기 때문에 함수가 호출된 위치는 상위 스코프 결정에 영향을 주지 않는다. 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프다. 

식별자는 어떤 값을 구별할 수 있어야 하므로 유일해야한다. 프로그래밍 언어에서는 스코프를 통해 식별자의 충동을 방지하여 같은 이름의 식별자를 사용할 수 있게 한다. 스코프 내에서는 식별자가 유일해야하지만 다른 스코프에서는 같은 이름의 식별자를 사용할 수 있다. 즉, 스코프는 네임스페이스다. 

*네임스페이스는 개체를 구분할 수 있는 범위를 뜻한다. 

코드 가장 바깥 영역, 즉 전역에 선언된 식별자는 전역스코프를  갖는다. 함수 몸체 내부, 즉 지역에 선언된 식별자는 지역스코프를 갖는다. 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다. (함수레벨 스코프)

*var키워드로 선언된 변수는 함수레벨 스코프를 갖지만, ES6에 도입된 let, const키워드로 선언된 변수는 블록레벨 스코프를 갖는다. 

스코프가 함수의 중첩(함수 몸체 내부에 정의한 함수)에 의해 계층적 구조를 갖는다. 스코프가 계층적으로 연결된 것을 스코프 체인이라고 한다. 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 **참조**하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 **선언**된 변수를 검색한다. 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다. 렉시컬 환경은 함수가 호출되면 바로 생성된다. 

*렉시컬 스코프와 클로저가 깊은 연관이 있다. 
<br>
<br>


# 14. 전역 변수의 문제점

변수는 자신이 선언된 위치에서 생성되고 소멸한다. 전역변수의 생명주기는 애플리케이션의 생명주기와 같고, 지역변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸된다. 지역변수의 생명주기는 자신이 선언된 함수의 생명주기와 같다. 

전역변수의 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다. 지역변수의 변수선언은 함수가 호출된 직후에 함수 몸체의 코드가 한줄씩 순차적으로 실행되기 전에 자바스크립트 엔진에 의해 먼저 실행된다. 

지역변수가 함수보다 오래 생존하는 경우도 있다. 변수는 스코프가 소멸될 때까지 유효하다. 즉, 누군가 스코프를 참조하고 있으면 소멸하지 않고 생존하게 된다. (모듈패턴, 클로저)

호이스팅은 **스코프 단위**로 동작한다. 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말한다. 

전역 코드는 명시적인 호출 없이 실행되고 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료한다. var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 

*전역 객체는 브라우저에서는 window객체, Node.js에서는 global객체이다. 전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체(클라이언트 web api, node.js 호스트 api) 그리고 var키워드로 선언한 전역변수와 전역함수를 프로퍼티로 갖는다. 


## 문제점

1. 암묵적 결합
    
    모든 코드가 전역변수를 참조하고 변경할 수 있는 암묵적 결합이 허용되기 때문에 의도치 않게 상태가 변경될 위험이 높아진다. 실수할 확률이 높다. 
    
2. 긴 생명주기
    
    메모리 리소스를 오랜 시간 차지하고 상태를 변경할 시간이 많다. 
    
3. 스코프 체인 상에서 종점에 존재
    
    가장 마지막에 검색되기 때문에 전역 변수의 검색 속도가 가장 느리다. 
    
4. 네임스페이스 오염
    
    파일이 분리되어 있다 해도 하나의 전역 스코프를 공유하기 때문에 다른 파일 내에서 전역변수나 전역함수가 같은 스코프에 존재할 경우 네임스페이스가 오염된다. 
    

## 전역변수 억제 방법

꼭 전역 변수를 사용해야할 이유가 없다면 지역 변수를 사용하는 게 좋다. 

1. 즉시실행함수
    
    변수가 즉시실행함수의 지역변수가 된다. 
    
2. 네임스페이스 객체
    
    네임스페이스 역할을 하는 객체를 생성하고 변수를 프로퍼티로 추가한다. (네임스페이스가 전역변수에 할당되므로 별로 유용하지는 않을 듯 하다)
    
3. 모듈패턴
    
    클래스처럼 변수와 함수를 모아 즉시 실행 함수로 감싸서 하나의 모듈을 만든다. 클로저 기반으로 동작하여 전역변수를 억제하면서 캡슐화까지 구현한다. 자바스크립트는 접근제한자를 제공하지 않지만 모듈패턴을 통해 정보은닉을 구현할 수 있다.
    
4. ES6 모듈
    
    파일 자체의 독자적인 모듈 스코프를 제공하기 때문에 전역 변수를 사용할 수 없다. 모듈 내의 var 변수는 전역변수도 아니고 window객체의 프로퍼티도 아니다.  
<br>
<br>

# 15. let, const 키워드와 블록 레벨 스코프

## var 변수의 문제점

1. 변수 중복 선언 허용
    
    var키워드가 없는 것처럼 동작한다. 즉, 재선언이 아니라 재할당된다. 
    
2. 함수 레벨 스코프
    
    함수의 코드블록만 지역 스코프로 인정한다.
    
3. 변수 호이스팅
    
    변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 선언문 이전에 변수를 참조할 수 있기 때문에 흐름에 맞지도 않고 가독성을 떨어뜨린다. 
    

var 키워드의 단점을 보완하기 위해 ES6에서는 새로운 변수 키워드인 let, const가 등장했다. 


## let 키워드

1. 변수 중복 선언 금지
    
    같은 스코프 내에서 중복 선언을 허용하지 않아서 문법에러가 발생한다.
    
2. 블록 레벨 스코프
    
    모든 코드 블록을 지역 스코프로 인정한다.  
    
3. 변수 호이스팅
    
    선언단계에서 스코프(실행컨텍스트의 렉시컬환경)에 식별자를 등록해서 자바스크립트 엔진에 변수의 존재를 알린다. var변수는 런타임 이전에 선언단계와 초기화단계가 한번에 진행되기 때문에 변수 선언문 이전에 접근해도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않고 undefined를 반환한다. let변수는 선언단계와 초기화단계가 분리되어 진행된다. 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달 했을때 즉, 런타임에 실행되기 때문에 선언문 이전에 변수에 접근하면 참조 에러가 발생한다. 스코프 시작 시점부터 초기화 단계 시작 시점까지 변수를 참조할 수 없다. (일시적 사각지대 Temporal Dead Zone)
    
4. 전역 객체와 let
    
    var키워드로 선언한 전역변수, 전역함수, 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역객체 window의 프로퍼티가 된다. 전역 객체 프로퍼티를 참조할 때 window를 생략할 수 있다. 
    
    let 변수는 전역 객체의 프로퍼티가 아니다. let 전역 변수는 개념적 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재하게 된다.  
    

*선언하지 않고 값을 할당한 변수는 스코프에 상관없이 암묵적 전역이 되는가

*암묵적 전역, 전역 변수랑 어떻게 다른가

*왜 전역변수는 객체 프로퍼티에서 delete되지 않는가? 프로퍼티 속성 중에 있지 않을까??

*객체의 프로퍼티 중에 configurable이나 뭐 다른걸 사용하면 불변 객체로 만들수 있지 않을까


## const 키워드

1. 선언과 초기화
    
    선언과 동시에 초기화해야 한다. 
    
2. 재할당이 금지 된다. 
3. 상수
    
    const 키워드로 선언한 변수에 원시값을 할당하는 경우 원시값은 변경 불가능한 값이므로 상수를 표현하는 데 사용한다.  상수는 재할당이 금지된 변수를 말한다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수다. 
    
4. const키워드와 객체
    
    const 키워드로 선언한 변수에 객체를 할당하는 경우 객체는 재할당 없이도 직접 변경이 가능하기 때문에 값을 변경할 수 있다. 객체는 프로퍼티의 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 변경이 가능하니까..
    

⇒ 즉, const는 재할당을 금지하는 것이지 불변을 의미하지 않는다.
